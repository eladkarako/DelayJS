{"name":"DelayJS","tagline":"Delayed Conditioning - The Easy Way","body":"### DelayJS\r\n\r\n***\r\n\r\nWrapping good old `setTimeout` to provide a recursive (but low-memory consumption), rapidly checking any state condition (you provide the function that does the checking), it is scope neutral and enable an asynchronous execution of callback method just when the condition has set to be true\r\n\r\n***\r\n\r\narguments are passed in the new advised JavaScript style, as an object container, to provide simplicity, readability and flexibility in code maintenance (it is actually, a new *thing*!)\r\n\r\n\r\n***\r\n\r\ncode is part of another project, enjoy ;)\r\n\r\n***\r\n\r\nnote that the code uses some minor object-prototyping\r\n```javascript\r\n/**\r\n * just like jQuery's $.extend.\r\n * @param  {Object=} obj\r\n * @return {Object}\r\n */\r\nObject.prototype.nExtend = function(obj) {\r\n  var key;\r\n  for (key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      this[key] = obj[key];\r\n    }\r\n  }\r\n  return this;\r\n};\r\n```\r\n\r\nmy arguments are objected into a nice `{}`, this way the whole thing is dynamic, an easily updated,\r\n\r\nsaving some text cluttering in the code here is the doc for the method\r\n```javascript\r\n/**\r\n * DelayJS is an easy to use delayed conditioning.\r\n *\r\n * @param {{\r\n     condition_function:      function(...[*]): boolean,\r\n     condition_callback:      function(),\r\n     delay_number:            number=,\r\n     limit_number:            number=,\r\n     limit_callback:          function()=,\r\n     DEBUG_MODE:              boolean=,\r\n     LAST:                    number=,\r\n     NOW:                     number=\r\n    }} args\r\n * @return {boolean} - true if condition is true, false if limit has reached.\r\n */\r\n```","google":"UA-58067712-1","note":"Don't delete this file! It's used internally to help with page regeneration."}